#+title: Embedded Systems with GNU/Linux: Opening the Black Box
#+author: Fabricio Puente Mansilla
#+email: fpuentem@visiontechconsulting.ca
#+date: <2025-05-17 Sat>

* Introduction & Setting the Stage
** Embedded systems are everywhere!
+ smart watch, router, car dashboard, industrial control
  #+ATTR_ORG: :width 50
  [[file:./images/embeddes-systems-everywhere.jpg]]
+ What is an embedded system?
  Simple definition: computer system designed for specific function.
+ Understand the fundamental concepts behind developing software for these systems, and why the right tools (like GNU/Linux) are essential.

** Your Daily Software Experience (The "Product" View)

** The "Black Box" Problem for Embedded Systems
+ This mindset hides key concepts that are CRITICAL when you have to build software for custom, resource-constrained hardware.
+ Architecture, Cross-Compilation, Source Code, Package Management, Version Control Systems.

** Why Embedded Systems Demand Deeper Understanding
+ Limited resources (CPU, RAM, storage).
+ Diverse hardware (not just x86).
+ Need for customization and optimization.
+ Often no screen/keyboard - different deployment methods.
+ You are the builder, not just the user.

* Unpacking the Hidden Concepts

** Concept 1: Architecture Compatibility
+ What is a CPU architecture? (x86, ARM, RISC-V - explain simply).
+ Show images/diagrams of different chip types.
+ Why does it matter? Software compiled for one architecture *usually* won't run on another.
+ In embedded: You *must* target the specific chip's architecture.

** Concept 2: Cross-Compilation
+  Compiling code on one machine (the "host") to run on a different machine (the "target").
+ Why needed for embedded? (Target might be too slow/small, or have a different architecture than your powerful development machine).
+ Simple diagram: Host PC -> Compiler -> Target Binary -> Embedded Device.
+ Contrast with Native Compilation (compiling and running on the same machine).

**  Concept 3: Source Code & The Build Process
 + What is source code? (Human-readable instructions).
 + Why is access important in embedded? (Customization, debugging low-level issues, understanding hardware interaction).
 + GitHub, GitLab
 + Basic Build Process: Source Code -> Compiler -> Object Files -> Linker -> Executable/Library.

** Concept 4: Package Management & Dependencies
+ What is a software package? (Bundled files, executables, libraries).
+ What are dependencies? (Software A needs Library B to run).
+ Managing many software components and their interdependencies manually is complex.
+ How desktop OS often hide this (bundled installers). Why that's not enough for building a whole embedded OS/system.

** Recap - The Gap
+ The "software as a product" model doesn't prepare you for these concepts, which are fundamental in embedded systems.

* GNU/Linux: The Development Playground

** Introducing GNU/Linux
+ Brief history/philosophy: Open source, transparency, control.
+ Not just a desktop OS, but a powerful toolkit for developers.
+ Contrast user experience: Command line, file system visibility, configuration files.

** How Linux Exposes the Concepts
+ Architecture: You see it in package names (~.deb~ for ~armhf~, ~amd64~), kernel versions.
+ Compilation: Compiling from source is a common task. You interact with compilers, makefiles.
+ Source Code: Readily available for kernel, tools, libraries. You're encouraged to look.
+ Package Management (~apt~, ~yum~, etc.): Explain how they manage dependencies explicitly, resolving conflicts, installing build tools.

** Why GNU/Linux is Ideal for Embedded Development
+ Access to essential open-source tools (GCC, GDB, Make, CMake, etc.).
+ Strong community support for embedded Linux development.
+ Flexibility to build custom systems.
+ Many embedded targets *run* Linux (like Raspberry Pi, NVIDIA Jetsons, Orage Pi, etc.).

** Bridging the Gap
+ Using GNU/Linux helps you move from consumer to creator/developer.
+ You gain the necessary vocabulary, workflows and practical experience.

* Section 4: Demo Time! Setting up for Cross-Compilation

** Demo Introduction: Our Mission
+ Goal: Set up our Ubuntu machine (Host, x86) to compile software for a Orange Pi (Target, ARM).
+ This is a practical example of cross-compilation and using Linux tools/package management.
+  Note: We won't compile the *entire* ARMbian, but we'll install the *tools required* and show how to use them on a simple example.

** *The Tools We Need*
+ Cross-compiler toolchain (e.g., ~gcc-arm-linux-gnueabihf~).
+ Necessary libraries and headers for the target architecture.
+ Mention these are available as packages in Ubuntu's repositories.

**  Step 1: Install the Toolchain
+ Show opening a terminal.
  #+BEGIN_SRC bash
    sudo apt update
    sudo apt install crossbuild-essential-armhf
  #+END_SRC

+ Explain what ~apt~ is doing: Downloading packages, resolving dependencies, installing files. Connect back to "Package Management".

** Step 2: Prepare Source Code
+ Navigate to a demo directory.
+ Create a simple C "Hello World" program (e.g., ~hello.c~).
+ Briefly explain the C code.

** Step 3: Cross-Compiling!
+ Show the cross-compilation command:
  #+BEGIN_SRC bash
    arm-linux-gnueabihf-gcc hello.c -o hello_pi
  #+END_SRC

+ Explain the command:
  + ~arm-linux-gnueabihf-gcc~: This is the *cross-compiler* executable (note the prefix indicating the target).
  + ~hello.c~: Input source file.
  + ~-o hello_pi~: Output executable name.
  + Show the output executable file (~hello_pi~).
    + Explain: This file is now compiled for ARM and *will not run* on our Ubuntu x86 machine directly.

** Verifying the Output / Running on Target (Show & Tell)
+ (If possible/time permits) Show ~file hello_pi~ output to demonstrate it's an ARM executable.
+ (Show image/short video) How you would transfer ~hello_pi~ to a Raspberry Pi and run it there. Emphasize this is the *deployment* step.

* Reflecting on the Demo & Next Steps

** Connecting the Demo Back to Concepts
+ We *cross-compiled* (Slide 19).
+ We targeted a specific *architecture* (ARM HF) (Slide 17, 19).
+ We worked with *source code* (Slide 18).
+ We used *package management* (~apt~) to get our tools (Slide 17).
+ Contrast again: How would you do *any* of this on a standard "product" OS without installing significant developer environments?

** *Beyond This Demo*
+ Mention that compiling a full OS involves build systems (Buildroot, Yocto - high level).
+ Briefly touch on bootloaders, kernels (Linux), root filesystems.
+ All these steps rely heavily on the concepts and tools available in a GNU/Linux environment.

** Where to Go From Here?
+ Encourage them to install GNU/Linux (Ubuntu, Fedora, etc.).
+ Explore the command line.
+ Look into embedded Linux resources (Raspberry Pi documentation, Buildroot/Yocto documentation).
+ Suggest projects (simple LED blink on Pi via SSH, controlling GPIO, kernel modules).

** *Q&A and Conclusion*
+ Summarize the main takeaway: Embracing GNU/Linux unlocks a deeper understanding of computing and is fundamental for embedded systems development.
+ Thank You!
+ Open floor for Questions.
